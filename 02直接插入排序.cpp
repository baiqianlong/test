/*
基本思想：直接插入排序，每次将一个新数据插入到有序队列中的合适位置里。
直接插入排序认为第一个元素是有序的，其余元素是无需无序的，从无需序列中
取出一个元素，与第一个元素比较，若大于，则插入到右边，小于则出入到左边，
这样有序序列的长度加1，并且任然有序，直到无需序列长度为0。

假设有一组无序序列 R0, R1, ... , RN-1。

(1) 我们先将这个序列中下标为 0 的元素视为元素个数为 1 的有序序列。

(2) 然后，我们要依次把 R1, R2, ... , RN-1 插入到这个有序序列中。所以，我们需要一个外部循环，从下标 1 扫描到 N-1 。

(3) 接下来描述插入过程。假设这是要将 Ri 插入到前面有序的序列中。由前面所述，我们可知，插入Ri时，前 i-1 个数肯定已经是有序了。

所以我们需要将Ri 和R0 ~ Ri-1 进行比较，确定要插入的合适位置。这就需要一个内部循环，我们一般是从后往前比较，即从下标 i-1 开始向 0 进行扫描。
	
*/
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<string>
#include<cmath>
#include<stdlib.h>
using namespace std;


int main(void)
{
	int a[] = { 98, 76, 109, 34, 67, 190, 80, 12, 14, 89, 1 };
	int k = sizeof(a) / sizeof(a[0]);
	int j;
	for (int i = 1; i < k; i++)//循环从第2个元素开始
	{
		if (a[i] < a[i - 1])
		{
			int temp = a[i];
			for (j = i - 1; j >= 0 && a[j] > temp; j--)
			{
				a[j + 1] = a[j];
			}
			a[j + 1] = temp;//此处就是a[j+1]=temp;
		}
	}
	/*
	(1)如果后面的一个元素的值不小于前面的值，则不需要操作
	（2）如果后面一个元素的值小于前面一个元素的值，则从后向前扫描
	（3）然后把后面元素的值赋值给一个临时变量，把i的值减少1并赋值给j；
	（4）把j（i-1）位置的变量后移一位，然后向前遍历，直到一个元素大于tem，跳出循环
		
	*/
	for (int f = 0; f < k; f++)
	{
		cout << a[f] << "  ";
	}
	
	system("pause");
	return 0;
}
/*
1  12  14  34  67  76  80  89  98  109  190  请按任意键继续. . .
Sunrise于东北电力大学第二教学楼1121实验室	
*/